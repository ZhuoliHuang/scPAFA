import pandas as pd
import anndata as ad
import numpy as np
import dask
import dask.dataframe as dd
import os
from pandarallel import pandarallel

'''
Introduction

1) Take the input cell * gene counts matrix and partition it by cells using the Dask framework. 
The number of cells per partition can be set by the user (default is 1000).

2) Within each partition, calculate the Rank matrix for individual cells (merge identical ranks using the average method). 
Filter out genes that do not belong to the input pathway from the Rank matrix.

3) Convert the results from each partition (matrix) into a long-format data frame. 
Then, filter out genes with a rank greater than maxRank (default is 2000). 
This is done to reduce the computational workload for subsequent U statistic calculations.

4) Calculate the number of rows in each long-format data frame for each partition. 
This represents the length of results generated by cells in each partition and is used for subsequent computations during the parallel apply step.

5) Merge the results and output the final result, which is a long-format Rank data frame containing genes that are both below maxRank and belong to the pathway in all cells.

6) Divide the long-format data frame into chunks based on the previously recorded row counts.
 Run the data for each chunk sequentially. 
 Within each individual chunk, use parallel apply to run the Ustat scoring function in parallel.

'''

#calculate n_row in the result of partition, this function is use to splice rank_dataframe 
def count_rows_in_partition(partition):
    return len(partition)

# calculate rank for each partition generate by dask
def rank_and_Ustat(dataframe,maxRank,overlapgene,floattype):
    dataframe = dataframe.rank(ascending=False,axis=1,method = 'average').astype(floattype)
    dataframe = dataframe[overlapgene]
    dataframe['Cell'] = dataframe.index
    dataframe = dataframe.melt(id_vars='Cell', var_name='Gene', value_name='Rank')
    dataframe = dataframe[dataframe['Rank'] <= maxRank]
    return(dataframe)

def Ustat(pathway_column,maxRank,info_Dict_dataframe,rank_dataframe,floattype):
    test_geneset = pathway_column.dropna().values
    test_geneset_name = pathway_column.name
    rank_dataframe.Cell = rank_dataframe.Cell.astype('category')
    rank_dataframe = rank_dataframe[rank_dataframe['Gene'].isin(test_geneset)]
    ranksum_dataframe = rank_dataframe.groupby('Cell')['Rank'].sum().reset_index().set_index('Cell')
    rank_dataframe = pd.concat([ranksum_dataframe,
                            rank_dataframe.Cell.value_counts().reset_index().set_index('Cell').reindex(ranksum_dataframe.index)],axis=1)
    pathway_length = info_Dict_dataframe.loc[test_geneset_name,'length']
    rank_dataframe['result'] = 0
    rank_dataframe.loc[rank_dataframe['count']>0,'result'] = 1-(((rank_dataframe.loc[rank_dataframe['count']>0,'Rank'] + ((maxRank+1)*(pathway_length-rank_dataframe.loc[rank_dataframe['count']>0,'count']))) - (0.5*pathway_length*(pathway_length+1)))/(maxRank*pathway_length))
    return(rank_dataframe['result'].astype(floattype))

def pyUCell(adata:ad.AnnData,
            n_cores:int = None,
            maxRank:int = 2000,
            input_dict:dict = None,
            chunksize:int = 1000,
            floattype:str = 'float32',
            chunksize_for_apply:int = 50):
    
    """
    Perform Parallelized Gene Ranking and U Statistical Testing within Pathways

    This function takes an AnnData object representing gene expression data and performs the following tasks:

    1. Partition the input gene counts matrix by cells using Dask framework.
    2. Calculate the rank matrix for individual cells within each partition.
    3. Filter genes not belonging to a specified pathway from the rank matrix.
    4. Convert the results into a long-format DataFrame, filtering genes with ranks exceeding a threshold.
    5. Calculate the number of rows in each partition.
    6. Merge and output a final long-format Rank DataFrame containing pathway genes within rank limits.

    Additionally, it divides the long-format DataFrame into chunks and applies a U statistic scoring function in parallel
    for each chunk.

    Parameters:
    ----------
    adata : ad.AnnData
        An AnnData object containing gene expression data.

    n_cores : int, optional
        Number of CPU cores to use for parallel processing (default is None, which auto-detects available cores).

    maxRank : int, optional
        Maximum rank threshold for gene filtering (default is 2000).

    input_dict : dict, optional
        A dictionary containing pathway and gene information needed for the analysis.

    chunksize : int, optional
        Chunk size for Dask DataFrame partitions (default is 1000, larger number will cost more memory).

    floattype : str, optional
        Data type for floating-point values (default is 'float32', can be set to'float16' to save memory).

    chunksize_for_apply : int, optional
        Chunk size for applying the U statistic function in parallel (default is 50 Kcells, a larger number may cause error).
    
    Returns:
    -------
    result_df : pd.DataFrame
        A Pandas DataFrame containing the final results of gene ranking and statistical testing within pathways.

    Notes:
    ------
    Ensure that the input data, such as 'adata' and 'input_dict', are correctly formatted and contain the required
    information for the analysis. The 'rank_and_Ustat' and 'Ustat' functions must be correctly defined and aligned
    with your analysis requirements.

    """

    max_cores = os.cpu_count()

    #check_input
    # 检查 adata 是否为 AnnData 对象
    assert isinstance(adata, ad.AnnData), "adata 必须是 AnnData 对象"
    
    # 检查 n_cores 是否为整数且小于设备最大核数，或者为 None
    assert n_cores is None or (isinstance(n_cores, int) and 0 < n_cores <= max_cores), "n_cores 必须为小于设备最大核数的整数或者 None"
    
    # 检查 maxRank 是否为整数
    assert isinstance(maxRank, int), "maxRank 必须为整数"
    
    # 检查 input_dict 是否为字典或者为 None
    assert input_dict is None or isinstance(input_dict, dict), "input_dict 必须为字典或者 None"
    
    # 检查 chunksize 是否为整数
    assert isinstance(chunksize, int), "chunksize 必须为整数"
    
    # 检查 floattype 是否为字符串 'float32' 或 'float16'
    assert floattype in ['float32', 'float16'], "floattype 必须为 'float32' 或 'float16'"
    
    # 检查 chunksize_for_apply 是否为整数
    assert isinstance(chunksize_for_apply, int), "chunksize_for_apply 必须为整数"
    
    dask.config.set(num_workers=n_cores)
    pandarallel.initialize(nb_workers=n_cores)
    
    Dict_dataframe =input_dict['pathway_dataframe']
    info_Dict_dataframe = input_dict['pathway_length_dataframe']
    intersectgene = input_dict['intersectgene']

    df = pd.DataFrame.sparse.from_spmatrix(adata.X,index=adata.obs_names,columns=adata.var_names)
    df_dask = dd.from_pandas(df,chunksize=chunksize,sort=False)
    print('Done_partitions')
    ranked_dfs = df_dask.map_partitions(rank_and_Ustat,maxRank = maxRank, overlapgene = intersectgene,floattype = floattype)
    ranked_dfs = ranked_dfs.persist()

    # 使用map_partitions应用自定义函数
    partition_row_counts = ranked_dfs.map_partitions(count_rows_in_partition, meta=('int', 'int'))
    # 使用compute方法计算结果并将其转换为Pandas Series

    row_counts = partition_row_counts.compute()
    chunks_for_apply = row_counts.groupby(row_counts.index // chunksize_for_apply).apply(sum)

    Rank_df = ranked_dfs.compute()
    Rank_df = Rank_df.reset_index()
    del(Rank_df['index'])

    result_df = pd.DataFrame()
    
    print(str(len(chunks_for_apply.index))+' batch need to process')
    
    for chunk_index in chunks_for_apply.index:
    
        print('processing_batch'+str(chunk_index))
        if chunk_index ==0:
            start = 0
            end = chunks_for_apply[0:(chunk_index+1)].sum()
        else:
            end = chunks_for_apply[0:(chunk_index+1)].sum()
            start = end - chunks_for_apply[chunk_index]
        use_rank = Rank_df.iloc[start:end]
        score = Dict_dataframe.parallel_apply(Ustat,maxRank=2000,info_Dict_dataframe=info_Dict_dataframe,rank_dataframe=use_rank,axis =0,floattype = floattype)
        result_df = pd.concat([result_df, score])
    return(result_df)